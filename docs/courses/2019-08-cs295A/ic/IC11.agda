module IC11 where

---------
-- LIB --
---------

-- equality --

infix 8 _â‰¡_
data _â‰¡_ {A : Set} (x : A) : A â†’ Set where
  â†¯ : x â‰¡ x
{-# BUILTIN EQUALITY _â‰¡_ #-}

-- booleans --

data ğ”¹ : Set where
  T : ğ”¹
  F : ğ”¹

-- naturals --

data â„• : Set where
  Z : â„•
  S : â„• â†’ â„•
{-# BUILTIN NATURAL â„• #-}

infixl 15 _+_
_+_ : â„• â†’ â„• â†’ â„•
Z    + n â€‚=â€‚ n
(S m) + n â€‚=â€‚ S (m + n)

infixl 16 _Ã—_
_Ã—_ : â„• â†’ â„• â†’ â„•
Z Ã— _ = Z
S m Ã— n = n + m Ã— n

-- order --

infix 8 _â‰¤_
data _â‰¤_ : â„• â†’ â„• â†’ Set where
  Z : âˆ€ {n} â†’ Z â‰¤ n
  S : âˆ€ {m n} â†’ m â‰¤ n â†’ S m â‰¤ S n

infix 8 _<_
data _<_ : â„• â†’ â„• â†’ Set where
  Z : âˆ€ {n} â†’ Z < S n
  S : âˆ€ {m n} â†’ m < n â†’ S m < S n

data â‰¤! : Set where
  [â‰¤] : â‰¤!
  [>] : â‰¤!

infix 8 _â‰¤â‹†!_
data _â‰¤â‹†!_ (m n : â„•) : Set where
  [â‰¤] : m â‰¤ n â†’ m â‰¤â‹†! n
  [>] : n < m â†’ m â‰¤â‹†! n

data â‹š! : Set where
  [<] : â‹š!
  [â‰¡] : â‹š!
  [>] : â‹š!

infix 8 _â‹šâ‹†!_
data _â‹šâ‹†!_ (m n : â„•) : Set where
  [<] : m < n â†’ m â‹šâ‹†! n
  [â‰¡] : m â‰¡ n â†’ m â‹šâ‹†! n
  [>] : n < m â†’ m â‹šâ‹†! n

_â‰¤?_ : â„• â†’ â„• â†’ â‰¤!
Z â‰¤? n = [â‰¤]
S m â‰¤? Z = [>]
S m â‰¤? S n = m â‰¤? n

_â‹š?_ : â„• â†’ â„• â†’ â‹š!
Z â‹š? Z = [â‰¡]
Z â‹š? S n = [<]
S m â‹š? Z = [>]
S m â‹š? S n = m â‹š? n

-- type-level connectives --

data ğŸ˜ : Set where

infixr 9 Â¬_
Â¬_ : Set â†’ Set
Â¬ A = A â†’ ğŸ˜

data ğŸ™ : Set where
  â€¢ : ğŸ™

infix 5 _âˆ¨_
data _âˆ¨_ (A B : Set) : Set where
  Inl : A â†’ A âˆ¨ B
  Inr : B â†’ A âˆ¨ B

infix 6 _âˆ§_
record _âˆ§_ (A B : Set) : Set where
  constructor âŸ¨_,_âŸ©
  field
    Ï€â‚ : A
    Ï€â‚‚ : B
open _âˆ§_

data existential (A : Set) (B : A â†’ Set) : Set where
  âŸ¨âˆƒ_,_âŸ© : âˆ€ (x : A) â†’ B x â†’ existential A B

-- lists --

infixr 20 _âˆ·_
data list (A : Set) : Set where
  [] : list A
  _âˆ·_ : A â†’ list A â†’ list A

length[list] : âˆ€ {A : Set} â†’ list A â†’ â„•
length[list] [] = 0
length[list] (x âˆ· xs) = 1 + length[list] xs

infix 8 _â‰¤[first]_
data _â‰¤[first]_ (m : â„•) : list â„• â†’ Set where
  [] : m â‰¤[first] []
  âŸ¨_âŸ© : âˆ€ {n ns}
    â†’ m â‰¤ n
    â†’ m â‰¤[first] n âˆ· ns

data sorted : list â„• â†’ Set where
  [] : sorted []
  _âˆ·_ : âˆ€ {x xs}
    â†’ x â‰¤[first] xs
    â†’ sorted xs
    â†’ sorted (x âˆ· xs)

infix 8 _â‰¤[all]_
data _â‰¤[all]_ (x : â„•) : list â„• â†’ Set where
  [] : x â‰¤[all] []
  _âˆ·_  : âˆ€ {y : â„•} {ys : list â„•}
    â†’ x â‰¤ y
    â†’ x â‰¤[all] ys
    â†’ x â‰¤[all] (y âˆ· ys)

infixl 16 _â§º_
_â§º_ : âˆ€ {A : Set} â†’ list A â†’ list A â†’ list A
[] â§º ys = ys
(x âˆ· xs) â§º ys = x âˆ· (xs â§º ys)

-- functions -- 

id : âˆ€ {A : Set} â†’ A â†’ A
id x = x

_âˆ˜_ : âˆ€ {A B C : Set} â†’ (B â†’ C) â†’ (A â†’ B) â†’ (A â†’ C)
(g âˆ˜ f) x = g (f x)

-- POSTULATES --

infixl 18 _âŠš[â‰¡]_
infixl 18 _âŠš[â‰¤]_
infixl 17 _â‹ˆ[â‰¤]_

postulate
  _âŠš[â‰¡]_ : âˆ€ {A} {x y z : A} â†’ y â‰¡ z â†’ x â‰¡ y â†’ x â‰¡ z
  â—‡[â‰¡] : âˆ€ {A} {x y : A} â†’ x â‰¡ y â†’ y â‰¡ x

  runit[+] : âˆ€ (m : â„•) â†’ m + 0 â‰¡ m
  assoc[+] : âˆ€ (m n p : â„•) â†’ m + (n + p) â‰¡ (m + n) + p
  commu[+] : âˆ€ (m n : â„•) â†’ m + n â‰¡ n + m

  lmono[+] : âˆ€ {m n} p â†’ m â‰¤ n â†’ m + p â‰¤ n + p
  rmono[+] : âˆ€ m {n p} â†’ n â‰¤ p â†’ m + n â‰¤ m + p

  runit[Ã—] : âˆ€ (m : â„•) â†’ m Ã— 1 â‰¡ m
  rzero[Ã—] : âˆ€ (m : â„•) â†’ m Ã— 0 â‰¡ 0
  assoc[Ã—] : âˆ€ (m n p : â„•) â†’ m Ã— (n Ã— p) â‰¡ (m Ã— n) Ã— p
  commu[Ã—] : âˆ€ (m n : â„•) â†’ m Ã— n â‰¡ n Ã— m
  ldist[Ã—] : âˆ€ (m n p : â„•) â†’ m Ã— (n + p) â‰¡ m Ã— n + m Ã— p
  rdist[Ã—] : âˆ€ (m n p : â„•) â†’ (m + n) Ã— p â‰¡ m Ã— p + n Ã— p

  runit[â§º] : âˆ€ (ms : list â„•) â†’ ms â§º [] â‰¡ ms
  assoc[â§º] : âˆ€ (ms ns ps : list â„•) â†’ ms â§º (ns â§º ps) â‰¡ (ms â§º ns) â§º ps

  xRx[â‰¤] : âˆ€ (m : â„•) â†’ m â‰¤ m
  _âŠš[â‰¤]_ : âˆ€ {m n p : â„•} â†’ n â‰¤ p â†’ m â‰¤ n â†’ m â‰¤ p
  _â‹ˆ[â‰¤]_ : âˆ€ {m n : â„•} â†’ m â‰¤ n â†’ n â‰¤ m â†’ m â‰¡ n

  Â¬xRx[<] : âˆ€ {m : â„•} â†’ m < m â†’ ğŸ˜
  _âŠš[<]_ : âˆ€ {m n p : â„•} â†’ n < p â†’ m < n â†’ m < p
  _âŠš[</â‰¤]_ : âˆ€ {m n p : â„•} â†’ n < p â†’ m â‰¤ n â†’ m < p
  _âŠš[â‰¤/<]_ : âˆ€ {m n p : â„•} â†’ n â‰¤ p â†’ m < n â†’ m < p
  _Â¬â—‡_ : âˆ€ {m n : â„•} â†’ m < n â†’ n < m â†’ ğŸ˜

  s[â‰¤] : âˆ€ (m : â„•) â†’ m â‰¤ S m
  s[<] : âˆ€ (m : â„•) â†’ m < S m

  to[</â‰¤] : âˆ€ {m n : â„•} â†’ m < n â†’ S m â‰¤ n
  fr[</â‰¤] : âˆ€ {m n : â„•} â†’ S m â‰¤ n â†’ m < n

  to[â‰¤/<] : âˆ€ {m n : â„•} â†’ m â‰¤ n â†’ m < S n
  fr[â‰¤/<] : âˆ€ {m n : â„•} â†’ m < S n â†’ m â‰¤ n

  wk[<] : âˆ€ {m n : â„•} â†’ m < n â†’ m â‰¤ n
  in[â‰¤] : âˆ€ {m n : â„•} â†’ m â‰¤ n â†’ m < n âˆ¨ m â‰¡ n

  snd[â‰¤?/â‰¤] : âˆ€ {m n : â„•} â†’ m â‰¤? n â‰¡ [â‰¤] â†’ m â‰¤ n
  snd[â‰¤?/>] : âˆ€ {m n : â„•} â†’ m â‰¤? n â‰¡ [>] â†’ n < m

  cmp[â‰¤?/â‰¤] : âˆ€ {m n : â„•} â†’ m â‰¤ n â†’ m â‰¤? n â‰¡ [â‰¤]
  cmp[â‰¤?/>] : âˆ€ {m n : â„•} â†’ n < m â†’ m â‰¤? n â‰¡ [>]

  snd[â‹š?/<] : âˆ€ {m n : â„•} â†’ m â‹š? n â‰¡ [<] â†’ m < n
  snd[â‹š?/â‰¡] : âˆ€ {m n : â„•} â†’ m â‹š? n â‰¡ [â‰¡] â†’ m â‰¡ n
  snd[â‹š?/>] : âˆ€ {m n : â„•} â†’ m â‹š? n â‰¡ [>] â†’ n < m

  cmp[â‹š?/<] : âˆ€ {m n : â„•} â†’ m < n â†’ m â‹š? n â‰¡ [<]
  cmp[â‹š?/â‰¡] : âˆ€ {m n : â„•} â†’ m â‰¡ n â†’ m â‹š? n â‰¡ [â‰¡]
  cmp[â‹š?/>] : âˆ€ {m n : â„•} â†’ n < m â†’ m â‹š? n â‰¡ [>]

  _â‰¤â‹†_ : âˆ€ (m n : â„•) â†’ m â‰¤â‹†! n
  _â‹šâ‹†_ : âˆ€ (m n : â„•) â†’ m â‹šâ‹†! n

-- well-founded --

data acc (x : â„•) : Set where
  Acc : (âˆ€ {y} â†’ y < x â†’ acc y) â†’ acc x

acc[<] : âˆ€ {m} (n : â„•) â†’ m < n â†’ acc m
acc[<] Z ()
acc[<] (S n) Z = Acc Î» where ()
acc[<] (S n) (S Îµ) = Acc Î» where Îµâ€² â†’ (acc[<] n) ( to[</â‰¤] Îµ âŠš[â‰¤/<] Îµâ€²)

wf[<] : âˆ€ (n : â„•) â†’ acc n
wf[<] n = Acc (acc[<] n)

-----------------
-- DEFINITIONS --
-----------------

-- vectors are lists which know their length --
data vec (A : Set) : â„• â†’ Set where
  [] : vec A Z
  _âˆ·_ : âˆ€ {n} â†’ A â†’ vec A n â†’ vec A (S n)

-- this just tells Agda to display vectors as `vec[ m ] A` instead of
-- `vec A m`
vec[_] : â„• â†’ Set â†’ Set
vec[ n ] A = vec A n
{-# DISPLAY vec A n = vec[ n ] A #-}

-- these patterns work for both lists and vectors
pattern [_] a = a âˆ· []
pattern [_,_] a b = a âˆ· [ b ]
pattern [_,_,_] a b c = a âˆ· [ b , c ]
pattern [_,_,_,_] a b c d = a âˆ· [ b , c , d ]
pattern [_,_,_,_,_] a b c d e = a âˆ· [ b , c , d , e ]
pattern [_,_,_,_,_,_] a b c d e f = a âˆ· [ b , c , d , e , f ]
pattern [_,_,_,_,_,_,_] a b c d e f g = a âˆ· [ b , c , d , e , f , g ]
pattern [_,_,_,_,_,_,_,_] a b c d e f g h = a âˆ· [ b , c , d , e , f , g , h ]
pattern [_,_,_,_,_,_,_,_,_] a b c d e f g h i = a âˆ· [ b , c , d , e , f , g , h , i ]
pattern [_,_,_,_,_,_,_,_,_,_] a b c d e f g h i j = a âˆ· [ b , c , d , e , f , g , h , i , j ]

-- matrices (which know their dimensions) are just vectors of vectors
-- (which know their lengths)
matrix[_,_] : â„• â†’ â„• â†’ Set â†’ Set
matrix[ m , n ] A = vec[ m ] (vec[ n ] A)

---------------
-- EXERCISES --
---------------

-- an example vector --
_ : vec[ 4 ] â„•
_ = {!!}

-- an example matrix --
_ : matrix[ 2 , 3 ] â„•
_ = {!!}

-- the length function on vectors
length : âˆ€ {A : Set} {m : â„•} â†’ vec[ m ] A â†’ â„•
length xs = {!!}

-- alwas returns the same number as the index `m`
known-length : âˆ€ {A : Set} {m : â„•} (xs : vec[ m ] A) â†’ length xs â‰¡ m
known-length xs = {!!}

-- we can define dot-product; notice how we know that the vectors have
-- the same length, so never have to deal with a [] on the left when
-- there is a _âˆ·_ on the right
infixl 16 _â‹…_
_â‹…_ : âˆ€ {m : â„•} â†’ vec[ m ] â„• â†’ vec[ m ] â„• â†’ â„•
xs â‹… ys = {!!}

-- concatenating two vectors; the new length is the sum of lengths
infixl 15 _â§»_
_â§»_ : âˆ€ {A : Set} {m n : â„•} â†’ vec[ m ] A â†’ vec[ n ] A â†’ vec[ m + n ] A
xs â§» ys = {!!}

-- reversing a vector; requires using a lemma in order to typecheck
reverse : âˆ€ {A : Set} {m : â„•} â†’ vec[ m ] A â†’ vec[ m ] A
reverse xs = {!!}

-- map for vectors is just like lists
map : âˆ€ {A B : Set} {m : â„•} â†’ (A â†’ B) â†’ vec[ m ] A â†’ vec[ m ] B
map f xs = {!!}

-- concat-map for vectors is also just like lists; the final length is
-- a multiplication; how cool is that?
concat-map : âˆ€ {A B : Set} {m n : â„•} â†’ vec[ m ] A â†’ (A â†’ vec[ n ] B) â†’ vec[ m Ã— n ] B
concat-map xs f = {!!}

-- this gives us access to â€œdo notationâ€
infixr 2 _>>=_
_>>=_ : âˆ€ {A B : Set} {m n : â„•} â†’ vec[ m ] A â†’ (A â†’ vec[ n ] B) â†’ vec[ m Ã— n ] B
_>>=_ = concat-map

-- a fancy name for the â€œsingletonâ€ vector
return : âˆ€ {A : Set} â†’ A â†’ vec[ 1 ] A
return x = {!!}

-- cartesian product for vectors; the final length is a multiplication
-- because it uses concat-map; again we need to use a lemma in order
-- to typecheck
infixl 16 _â¨³_
_â¨³_ : âˆ€ {A B} {m n : â„•} (xs : vec[ m ] A) (ys : vec[ n ] B) â†’ vec[ m Ã— n ] (A âˆ§ B)
xs â¨³ ys = {!!}

-- remember selection sort on lists?

find-min[list] : â„• â†’ list â„• â†’ â„• âˆ§ list â„•
find-min[list] x [] = âŸ¨ x , [] âŸ©
find-min[list] x (y âˆ· ys) with x â‰¤? y
â€¦ | [â‰¤] =
  let âŸ¨ x , zs âŸ© = find-min[list] x ys
  in âŸ¨ x , y âˆ· zs âŸ©
â€¦ | [>] =
  let âŸ¨ x , zs âŸ© = find-min[list] y ys
  in âŸ¨ x , x âˆ· zs âŸ©

{-# TERMINATING #-}
ssort[list] : list â„• â†’ list â„•
ssort[list] [] = []
ssort[list] (x âˆ· xs) =
  let âŸ¨ x , ys âŸ© = find-min[list] x xs
  in x âˆ· ssort[list] ys

-- the termination proof for selection sort was painful; with vectors
-- it's very easy:

find-min : âˆ€ {m : â„•} â†’ â„• â†’ vec[ m ] â„• â†’ â„• âˆ§ vec[ m ] â„•
find-min x [] = âŸ¨ x , [] âŸ©
find-min x (y âˆ· ys) with x â‰¤? y
â€¦ | [â‰¤] = {!!}
â€¦ | [>] = {!!}

-- Agda accepts this because lists know their length, and `ys` in the
-- recursive call is of strictly smaller length. In order for this to
-- work, `find-min` must return a list with length equal to the input
-- list
ssort : âˆ€ {m : â„•} â†’ vec[ m ] â„• â†’ vec[ m ] â„•
ssort xs = {!!}

-- if you want to work with graphs for your final project, a nice
-- representation is an adjacency matrix (i.e., a matrix of booleans)
-- which indicates which nodes have an edge to which other nodes. If
-- you want to annotate edges with information you can use an â€œoptionâ€
-- instead of a boolean.
graph : â„• â†’ Set
graph n = matrix[ n , n ] ğ”¹
