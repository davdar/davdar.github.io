<!doctype html>
<html lang="en">
<head>
  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">

  <!-- Darais CSS -->
  <link rel="stylesheet" href="http://david.darais.com/css/darais-v0.0.0.1.css">

  <!-- Title -->
  <meta name="title" content="Lecture Notes: 06">

</head>

<body>

<main>

<pre class=markdown>

# Announcements

I will let people who submitted HW1 on time to re-submit for up to full credit.

I will let people who did not submit HW1 to re-submit for up to half credit.

So far 15 responses to office hours poll---I will stop taking responses on
Tuesday after class.

# Variables and Scope

Let's add variables to our language. In addition to variables, we are going to
allow for the ability to give local names to intermediate computations.

    e âˆˆ expr â©´ i
             | e + e
             | e Ã— e
             | b
             | IF e THEN e ELSE e
             | x              -- new
             | LET x = e IN e -- new

The idea behind â€œLETâ€ is it lets you reuse the result of a computation by name,
and the idea behind a variable is it lets you access these stored results.

## Well Formed Programs

We have our first syntactic notion of well-formedness. The main ideas are that
(1) a variable is only meaningful if it is in scope and (2) it is possible to
determine whether or not a given variable will be in scope by looking at the
program (i.e., you don't have to run it).

Let's look at some programs:

    LET x = 1 + 1 IN x
    LET x = 1 + 1 IN y
    LET x = y IN x
    LET y = 1 + 1 IN LET x = y IN x
    x

Some terminology:

- â˜‘ **binder**: the place where a variable is bound by name
- â˜‘ **binder scope**: the part of the term in which a binder is â€œin scopeâ€
- â˜‘ **free variable**: variables which occur in a term which are not â€œin scopeâ€
- â˜‘ **open term**: a term with free variable
- â˜‘ **closed term**: a term with no free variables

A program is â€œwell formedâ€ if all variables in the expression are in scope.
Let's try to write well-formed as a recursive predicate.

    WF âˆˆ expr â†’ ð”¹
    WF(i) â‰œ true
    WF(eâ‚ + eâ‚‚) â‰œ WF(eâ‚) âˆ§ WF(eâ‚‚)
      â‹®
    WF(x) â‰œ ??
    WF(LET x = eâ‚ IN eâ‚‚) â‰œ WF(eâ‚) âˆ§ WF(eâ‚‚)

There is not enough information in our recursive definition. What we need is to
(1) collect variables which are â€œin scopeâ€, and then (2) make sure all
variables are â€œin scopeâ€.

Here is the well-formedness check:

    WF âˆˆ â„˜(var) Ã— expr â†’ ð”¹
    WF(S,i) â‰œ true
    WF(S,eâ‚ + eâ‚‚) â‰œ WF(S,eâ‚) âˆ§ WF(S,eâ‚‚)
    WF(S,eâ‚ Ã— eâ‚‚) â‰œ WF(S,eâ‚) âˆ§ WF(S,eâ‚‚)
    WF(S,b) â‰œ true
    WF(S,IF eâ‚ THEN eâ‚‚ ELSE eâ‚ƒ) â‰œ WF(S,eâ‚) âˆ§ WF(S,eâ‚‚) âˆ§ WF(S,eâ‚ƒ)
    WF(S,x) â‰œ x âˆˆ? S
    WF(S,LET x = eâ‚ IN eâ‚‚) â‰œ WF(S,eâ‚) âˆ§ WF({x}âˆªS,eâ‚‚)

A simpler computation is to compute the â€œfree variablesâ€ of a term. When there
are no free variables, the term is well-formed:

    FV âˆˆ expr â†’ â„˜(var)
    FV(i) â‰œ âˆ…
    FV(eâ‚ + eâ‚‚) â‰œ FV(eâ‚) âˆª FV(eâ‚‚)
    FV(eâ‚ Ã— eâ‚‚) â‰œ FV(eâ‚) âˆª FV(eâ‚‚)
    FV(b) â‰œ âˆ…
    FV(IF eâ‚ THEN eâ‚‚ ELSE eâ‚ƒ) â‰œ FV(eâ‚) âˆª FV(eâ‚) âˆª FV(eâ‚ƒ)
    FV(x) â‰œ {x}
    FV(LET x = eâ‚ IN eâ‚‚) = FV(eâ‚) âˆª (FV(eâ‚‚) âˆ– {x})

You need to implement `FV` in homework 3, and the check `is-closed` which is
true if and only if the term is well-formed.

    closed(e) â‰œ FV(e) = âˆ…
    âˆ… âŠ¢ e  âŸº   FV(e) = âˆ…

We will come back to definitions in judgmental style when we cover type systems
and operational semantics later in the course.

Lecture Code Notes [Lc6.hs](../lc/Lc6.hs):

    -- Lecture Code Notes
    module Lc6 where
    
    import Data.Set (Set)
    import qualified Data.Set as Set
    
    -----------
    -- Lists --
    -----------
    
    data Expr = IntE Integer
              | PlusE Expr Expr
              | TimesE Expr Expr
              | BoolE Bool
              | IfE Expr Expr Expr
              -- new things
              | VarE String
              | LetE String Expr Expr
    
    -- v âˆˆ var â‰œ string
    -- S âˆˆ scope â‰œ â„˜(var)
    --
    -- S âŠ¢ e âˆˆ prop
    wellFormed :: Set String -> Expr -> Bool
    -- â”€â”€â”€â”€â”€
    -- S âŠ¢ i
    wellFormed scope (IntE i) = True
    -- S âŠ¢ eâ‚
    -- S âŠ¢ eâ‚‚
    -- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    -- S âŠ¢ eâ‚ + eâ‚‚
    wellFormed scope (PlusE e1 e2) = wellFormed scope e1 && wellFormed scope e2
    -- S âŠ¢ eâ‚
    -- S âŠ¢ eâ‚‚
    -- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    -- S âŠ¢ eâ‚ Ã— eâ‚‚
    wellFormed scope (TimesE e1 e2) = wellFormed scope e1 && wellFormed scope e2
    -- â”€â”€â”€â”€â”€
    -- S âŠ¢ b
    wellFormed scope (BoolE b) = True
    -- S âŠ¢ eâ‚
    -- S âŠ¢ eâ‚‚
    -- S âŠ¢ eâ‚ƒ
    -- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    -- S âŠ¢ IF eâ‚ THEN eâ‚‚ ELSE eâ‚ƒ
    wellFormed scope (IfE e1 e2 e3) = wellFormed scope e1 && wellFormed scope e2 && wellFormed scope e3
    -- x âˆˆ S
    -- â”€â”€â”€â”€â”€
    -- S âŠ¢ x
    wellFormed scope (VarE x) = x `Set.member` scope
    -- S âŠ¢ eâ‚
    -- {x}âˆªS âŠ¢ eâ‚‚
    -- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    -- S âŠ¢ LET x = eâ‚ IN eâ‚‚
    wellFormed scope (LetE x e1 e2) = wellFormed scope e1 && wellFormed (Set.singleton x `Set.union` scope) e2
    
    -- closed(e) âŸº  âˆ… âŠ¢ e
    closed :: Expr -> Bool
    closed e = wellFormed Set.empty e
    
    -- x
    e1 :: Expr
    e1 = VarE "x"
    
    -- LET x = 1 IN x
    e2 :: Expr
    e2 = LetE "x" (IntE 1) (VarE "x")
    
    -- LET x = 1 IN y
    e3 :: Expr
    e3 = LetE "x" (IntE 1) (VarE "y")
    
    -- LET x = x IN x
    e4 :: Expr
    e4 = LetE "x" (VarE "x") (VarE "x")
</pre>

</main>

<!-- Bootstrap core JavaScript -->
<!-- ================================================== -->
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
<!-- ================================================== -->

<script>
</script>
  
<!-- Showdown -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/1.8.6/showdown.min.js"></script>

<!-- Darais JS -->
<script src="http://david.darais.com/js/darais-v0.0.0.2.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-70126522-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-70126522-1');
</script>

</body>
</html>
