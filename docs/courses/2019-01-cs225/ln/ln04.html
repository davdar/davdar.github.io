<!doctype html>
<html lang="en">
<head>
  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">

  <!-- Darais CSS -->
  <link rel="stylesheet" href="http://david.darais.com/css/darais-v0.0.0.1.css">

  <!-- Title -->
  <meta name="title" content="Lecture Notes: 04">

</head>

<body>

<main>

<pre class=markdown>

*Review HW1 Solutions.*

# Desugaring

There are two ways to add a new feature to a programming language:

1. â˜‘ Give meaning to the feature via interpretation function
2. â˜‘ Give meaning to the feature based on existing features

(2) is done through a process called â€œdesugaringâ€. Some features in programming
languages do not increase the expressive power of the language. For example,
because our language has addition and multiplication, it is possible to encode
subtraction through a combination of addition and multiplication with `-1`.

    x - y = x + (-1) Ã— y

We now have *three* objects of interest: the â€œsourceâ€ language (the language
which includes subtraction), the â€œcoreâ€ language (the language with just plus
and multiplication), and the â€œdomainâ€ of interpretation (integers).

Formally, our source language now looks like this:

    eâ‚› âˆˆ sexpr â©´ i
              | eâ‚› + eâ‚›
              | eâ‚› Ã— eâ‚›
              | eâ‚› - eâ‚›

our core language looks like this:

    e âˆˆ cexpr â©´ i
              | e + e
              | e Ã— e

and our doman of interpretation looks like this:

    v âˆˆ value â©´ i

The desugaring of subtraction is a recursive traversal of the term:

    desugar âˆˆ sexp â†’ cexp
    desugar(i) â‰œ i
    desugar(eâ‚›â‚ + eâ‚›â‚‚) â‰œ desugar(eâ‚›â‚) + desugar(eâ‚›â‚‚)
    desugar(eâ‚›â‚ Ã— eâ‚›â‚‚) â‰œ desugar(eâ‚›â‚) Ã— desugar(eâ‚›â‚‚)
    desugar(eâ‚›â‚ - eâ‚›â‚‚) â‰œ desugar(eâ‚›â‚) + (-1) Ã— desugar(eâ‚›â‚‚)

â˜‘ Note that the right-hand-side is syntax, not math.

The interpreter is the same as before:

    interp âˆˆ cexp â†’ value
    interp(i) â‰œ i
    interp(eâ‚ + eâ‚‚) â‰œ interp(eâ‚) + interp(eâ‚‚)
    interp(eâ‚ Ã— eâ‚‚) â‰œ interp(eâ‚) Ã— interp(eâ‚‚)

Q: how would you encode unary negation?

    e âˆˆ sexpr â©´ i
              | eâ‚› + eâ‚›
              | eâ‚› Ã— eâ‚›
              | eâ‚› - eâ‚›
              | neg eâ‚›

    desugar âˆˆ sexp â†’ cexp
    ðŸ ?? desugar(neg eâ‚›) â‰œ 0 - desugar(eâ‚›)
    ðŸ ?? desugar(neg eâ‚›) â‰œ desugar(0 - eâ‚›)
    ðŸ‘ ?? desugar(neg eâ‚›) â‰œ (-1) Ã— desugar(eâ‚›)

The 3rd solution is the â€œpreferredâ€ one. The 2nd one works. The 1st one doesn't
work. (why not??)

# Partiality in Interpretation

Let's unwind and consider another extension which can't be desugared: division:

    e âˆˆ cexpr â©´ i
              | e + e
              | e Ã— e
              | e / e

Our interpreter is changed in two ways:

1. the set `value` now contains rational numbers, not integers
2. the interpreter is undefined in some cases (a.k.a, is partial), e.g., `5 /
   0` has no meaning

To handle (1) we redefine values to be rational numbers `q âˆˆ â„š`:

    v âˆˆ value â©´ q âˆˆ â„š

There are two ways to communicate the meaning of expressions. One is to defer
to what is defined or not in math:

    interp âˆˆ cexpr â‡€ value
      â‹®
    interp(eâ‚ / eâ‚‚) â‰œ interp(eâ‚) / interp(eâ‚‚)

This is â€œnot wrongâ€, but we can do better by making the â€œpartialityâ€ explicit.
To do this, we define a new set `answer` as follows:

    a âˆˆ answer â©´ v
               | BAD

The answer `BAD` is an explicit result value that means â€œsomething bad
happenedâ€. For this language, we will signal `BAD` when division by zero
happens.

    interp âˆˆ cexp â†’ answer
      â‹®
    interp(eâ‚ / eâ‚‚) â‰œ qâ‚ / qâ‚‚
      when interp(eâ‚) = qâ‚
      and  interp(eâ‚‚) = qâ‚‚
      and  qâ‚‚ â‰  0
    interp(eâ‚ / eâ‚‚) â‰œ BAD
      when interp(eâ‚) = BAD
      or   interp(eâ‚‚) = BAD
      or   interp(eâ‚‚) = 0

We can write this in another style as follows:

    interp âˆˆ cexp â†’ answer
    interp(eâ‚ / eâ‚‚) â‰œ 
      case interp(eâ‚),interp(eâ‚‚):
        qâ‚,qâ‚‚ | qâ‚‚ â‰  0 â†’ qâ‚ / qâ‚‚
        qâ‚,qâ‚‚ | qâ‚‚ = 0 â†’ BAD
        BAD,qâ‚‚ â†’ BAD
        qâ‚,BAD â†’ BAD
        BAD,BAD â†’ BAD

Lecture Code Notes [Lc4.hs](../lc/Lc4.hs):

    -- Lecture Code Notes
    module Lc4 where
    
    import Data.Ratio -- support for rational numbers (type Rational)
    
    -- e âˆˆ cexpr â©´ i
    --           | e + e
    --           | e Ã— e
    data ExprC = IntEC Integer
               | PlusEC ExprC ExprC
               | TimesEC ExprC ExprC
      deriving (Eq,Ord,Read,Show)
    
    -- eâ‚› âˆˆ sexpr â©´ i
    --            | e + e
    --            | e Ã— e
    --            | e - e
    --            | neg e
    data ExprS = IntES Integer
               | PlusES ExprS ExprS
               | TimesES ExprS ExprS
               | MinusES ExprS ExprS
               | NegateES ExprS
      deriving (Eq,Ord,Read,Show)
    
    interp :: ExprC -> Integer
    interp (IntEC i) = i
    interp (PlusEC e1 e2) = interp e1 + interp e2
    interp (TimesEC e1 e2) = interp e1 * interp e2
    
    desugar :: ExprS -> ExprC
    desugar (IntES i) = IntEC i
    desugar (PlusES e1 e2) = PlusEC (desugar e1) (desugar e2)
    desugar (TimesES e1 e2) = TimesEC (desugar e1) (desugar e2)
    desugar (MinusES e1 e2) = PlusEC (desugar e1) (TimesEC (IntEC (-1)) (desugar e2))
    desugar (NegateES e) = TimesEC (IntEC (-1)) (desugar e)
    
    -- e âˆˆ cexpr â©´ i
    --           | e + e
    --           | e Ã— e
    --           | e / e
    data ExprD = IntED Integer
               | PlusED ExprD ExprD
               | TimesED ExprD ExprD
               | DivideED ExprD ExprD
      deriving (Eq,Ord,Read,Show)
    
    -- v âˆˆ value â©´ q âˆˆ â„š
    type Value = Rational
    
    -- a âˆˆ answer â©´ v
    --            | BAD
    data Answer = ValA Value
                | BadA
      deriving (Eq,Ord,Read,Show)
    
    interpD :: ExprD -> Answer
    interpD (IntED i) = ValA (fromIntegral i)
    interpD (PlusED e1 e2) = case (interpD e1,interpD e2) of
      (ValA q1,ValA q2) -> ValA (q1 + q2)
      _ -> BadA
    interpD (TimesED e1 e2) = case (interpD e1,interpD e2) of
      (ValA q1,ValA q2) -> ValA (q1 * q2)
      _ -> BadA
    interpD (DivideED e1 e2) = case (interpD e1,interpD e2) of
      (ValA q1,ValA q2) | q2 /= 0 -> ValA (q1 / q2)
      _ -> BadA
</pre>

</main>

<!-- Bootstrap core JavaScript -->
<!-- ================================================== -->
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
<!-- ================================================== -->

<script>
</script>
  
<!-- Showdown -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/1.8.6/showdown.min.js"></script>

<!-- Darais JS -->
<script src="http://david.darais.com/js/darais-v0.0.0.2.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-70126522-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-70126522-1');
</script>

</body>
</html>
