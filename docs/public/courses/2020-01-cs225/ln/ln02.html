<!doctype html>
<html lang="en">
<head>
  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">

  <!-- Darais CSS -->
  <link rel="stylesheet" href="http://david.darais.com/css/darais-v0.0.0.3.css">

  <!-- Title -->
  <meta name="title" content="!!!TITLE!!!">

</head>

<body>

<main>

<pre class=markdown>
[02 - Course Technical Introduction](#title)

# Course Technical Introduction

## Context w.r.t. Models of Computation

- First(ish) model of computation: Turing Machines (TM) (Turing, 1936)
  - First model for what an algorithm (1) *is*, (2) *is capable of* and (3) *is
    not capable of*.
  - Low level, intuitive abstraction for a â€œmachineâ€
  - â€œTransition rulesâ€ as (not great) abstraction for code
  - â€œInfinite tapeâ€ as (good) abstraction for memory
  - â€œRule applicationâ€ as (mixed) abstraction for program execution
  - Not a programming language
  - More related to language recognition and hierarchies (e.g., regular,
    context-free languages)

E.g.:

    âŸ¨Q,Î“,b,Î£,Î´,qâ‚€,FâŸ©
    Q â‰œ {1,2,3}           -- states
    F â‰œ {'a','b',' '}     -- tape alphabet
    b â‰œ ' '               -- blank symbol
    Î£ â‰œ {'a','b'}         -- input alphabet
    qâ‚€ â‰œ 1                -- initial state
    F â‰œ {2,3}             -- halting states
    Î´(1,'a') â‰œ (' ',2,R)  -- transition rule
    Î´(1,'b') â‰œ (' ',3,R)  -- transition rule

- Second(ish) model of computation: Lambda Calculus (LC) (Church, 1936)
  - Church and Turing were buds
  - Simpler than TMs
  - Direct connections with formal logic
  - Hoped to also provide foundation for mathematics
  - â€œSymbolic expressionâ€ as (good) abstraction for code
  - â€œSize of symbolic expressionâ€ as (not great) abstraction for memory
  - â€œSubstitutionâ€ as (mixed) abstraction for program execution
  - Basis for understanding programming language features
  - Basis for design of all functional programming languages

E.g.:

    Î»x.x      -- conditional
    Î»x.Î»y.x   -- true
    Î»x.Î»y.y   -- false

*Early programming languages looked more like Turing Machines, modern
programming languages look more like lambda calculus.* (Although, hardware
still looks closer to turing machines.) They were invented around the same
time...

*Running theme in this course: Most â€œnewâ€ ideas in programming language design
are actually quite old.*

TM and LC were developed to study what computer programs are capable of. For
example, there is Turing's famous halting problem which states:

> There does not exist a turing machine M that takes as input another turing
> machine N, and eventually halts with one output bit which is true iff N
> halts, and false iff N does not halt.

I.e., the â€œhalting problemâ€ is undecidable.

## Programming Language Semantics

What does this program mean? (APL, 1966)

    â†‘+.Ã—/N/âŠ‚2 2â´1 1 1 0

*Obviously* this is the Fibonacci sequence. How do we *show* this is the case?
We need a semantics for APL, and a description of the Fibonacci sequence in
that semantic domain. Here's what this looks like abstractly.

(examples taken from: http://microapl.com/APL/getting_started_chapter1.html)

    APL-term âˆˆ set

    e.g., 
      1 âˆˆ APL-term             -- evaluates to 1
      1+1 âˆˆ APL-term           -- evaluates to 2
      1+1 2 3 âˆˆ APL-term       -- evaluates to 2 3 4
      1 2+3 4 5 âˆˆ? APL-term    -- error (syntax error or evaluation error?)
      3Ã—3-1 âˆˆ APL-term         -- evaluates to 6
      2 3 1+8Ã·2 2 2 âˆˆ APL-term -- evaluates to 6 7 5

Now that we have a (mathematical) set of APL-terms, let's define a
(mathematical) set for results of APL expressions:

    â„ âˆˆ set
    â„* âˆˆ set

    APL-result âˆˆ set
    APL-result â‰œ â„*

What does `â„*` mean?

    â„Â¹ â‰œ â„
    â„Â² â‰œ â„ Ã— â„ 
       = {âŸ¨x,yâŸ© | x âˆˆ â„, y âˆˆ â„}
    â„Â³ â‰œ â„ Ã— â„ Ã— â„
    â„* â‰œ âˆƒnâˆˆâ„•. â„â¿
    APL-result â‰œ â„*

The notation is precise (good) but more intimidating than necessary. `â„*` is
just a list of real numbers. In java, you might use the type `double[]` or
`ArrayList<Double>`.

Programming languages are given meaning through an *interpretation* function,
written with funny brackets called â€œOxford bracketsâ€:

    âŸ¦_âŸ§ âˆˆ APL-term â‡€ APL-result

Note the funny arrow, also called an "arrow hook". This arrow means a partial
function. Think of it for now as a function which returns a result on some
inputs, and crashes on others.

*Aside:* We often standardize on metavariables to implicitly always live in a
particular set. We will use the following implicit metavariables:

    r âˆˆ â„
    e âˆˆ APL-term

The set `APL-term` is defined as an inductively defined set:

    râ‚ â€¦ râ‚™ âˆˆ APL-term      -- râ‚ â€¥ râ‚™ IS AN APL-term

    eâ‚ âˆˆ APL-term           -- IF eâ‚ IS AN APL-term
    eâ‚‚ âˆˆ APL-term           -- AND eâ‚‚ IS AN APL-term
    ----------------------  --
    eâ‚ + eâ‚‚ âˆˆ APL-term      -- THEN eâ‚ + eâ‚‚ IS AN APL-term

    e âˆˆ APL-term            -- IF e IS AN APL-term
    ----------------        --
    r Ã— e âˆˆ APL-term        -- THEN r Ã— e IS AN APL-term

which is often abbreviated as:

    e âˆˆ APL-term â©´ r â€¦ r | e + e | r Ã— e

This structured definition of programming language *syntax* is called a "BNF"
grammar, which means either â€œBackus-Naur Formâ€ (famously formerly â€œBackus
Normal Formâ€).

The interpretation function is defined by induction on the syntax.

    âŸ¦râ‚ â€¦ râ‚™âŸ§ â‰œ âŸ¨râ‚,â€¦,râ‚™âŸ© âˆˆ â„â¿ âŠ† â„*
    âŸ¦eâ‚ + eâ‚‚âŸ§ â‰œ âŸ¨râ‚+sâ‚,â€¦,râ‚™+sâ‚™âŸ© âˆˆ â„â¿ âŠ† â„*
      where
        âŸ¨râ‚,â€¦,râ‚™âŸ© = âŸ¦eâ‚âŸ§ âˆˆ â„â¿
        âŸ¨sâ‚,â€¦,sâ‚™âŸ© = âŸ¦eâ‚‚âŸ§ âˆˆ â„â¿
    âŸ¦r Ã— eâŸ§ â‰œ âŸ¨rÃ—sâ‚,â€¦,rÃ—sâ‚™âŸ© âˆˆ â„â¿ âŠ† â„*
      where
        âŸ¨sâ‚,â€¦,sâ‚™âŸ© = âŸ¦eâŸ§ âˆˆ â„â¿

Note that this definition is partial because `âŸ¦eâ‚ + eâ‚‚âŸ§` requires the meaning
of both `eâ‚` and `eâ‚‚` to have the same dimension. This is why the set that
`âŸ¦_âŸ§` lives in was written with a `â‡€` and not `â†’`â€”to indicate this
â€œpartialityâ€.

Moving to a slightly more abstract description:

*A â€œlanguageâ€ `â„’` is some inductively defined set of sequences of symbols,
where each symbol has finite length.*

*A â€œdenotationâ€ `ğ’Ÿ` is some well-defined mathematical set.*

*A â€œdenotational semanticsâ€ is (usually) a function `âŸ¦_âŸ§ âˆˆ â„’ â†’ ğ’Ÿ` which gives mathematical
meaning to language terms.*

*An â€œinterpreterâ€ is (for our current purposes) a denotational semantics
implemented as a program you can run.

*Aside:* What happened to the partiality of `âŸ¦_âŸ§`, i.e., the partial arrow
â€œ`â‡€`â€? Partiality is easy to disguise as totality by extending a set with a
distinguished element `âŠ¥`. Formally, this equivalence is written `A â‡€ B = A â†’ B
âŠ {âŠ¥}`. The operator `âŠ` is pronounced â€œdisjoint unionâ€ and `{âŠ¥}` is a
singleton set. `B âŠ {âŠ¥}` means â€œa set that is just like B, but contains exactly
one new element `âŠ¥`, which is guaranteed to be different than all elements of
`B`.â€

Why are we doing this? Consider these two APL programs:

    eâ‚ â‰œ 3 4+3 4

    eâ‚‚ â‰œ 2Ã—3 4

These are *different programs*, that is, `eâ‚ â‰  eâ‚‚`, however, they are
*equivalent programs*, i.e., they have the same meaning, which is shown by
`âŸ¦eâ‚âŸ§ = âŸ¦eâ‚‚âŸ§`.

The value of this approach is we can extend our notion of equivalence to
programs with variables:

    eâ‚ â‰œ a b+a b
    eâ‚‚ â‰œ 2Ã—a b
  
These *programs fragments* are also equivalent, even thought they are not
â€œcomplete programsâ€ (i.e., they have â€œfree variablesâ€).

*Aside:* what's a compiler? A compiler is (1) another language `ğ’` which is
typically a much lower level of abstraction, and suitable for execution on
hardware (e.g., assembly code), (2) a semantics for `ğ’` as `âŸ¦_âŸ§ âˆˆ ğ’ â†’ ğ’Ÿ`, and
(3) a function `compile âˆˆ â„’ â†’ ğ’` which preserves the meaning of programs, that
is, `âŸ¦compile(e)âŸ§ = âŸ¦eâŸ§`.

           âŸ¦â‹…âŸ§
    e --------------â†’ dâ‚
    |                 â€–
    |compile          â€–
    â†“                 â€–
    c --------------â†’ dâ‚‚
           âŸ¦â‹…âŸ§

An important achievement in the field of programming languages is the design of
correct compilers, which are proven correct on paper, and more recently, proven
correct using computer-checked proofs. For any of this to work, compiler
designers need to be precise about modeling programming languages and their
semantics.

## Course Structure

The first 1/2 of the course will follow a pattern:

1. Start with the smallest language we can think of: `â„’`
2. Design a domain `ğ’Ÿ` in which we will give meaning to the language
3. Implement and interpreter for this language in Haskell (`âŸ¦_âŸ§ âˆˆ â„’ â†’ ğ’Ÿ`)
4. Extend the language with one new programming language feature
5. GOTO 2

Along the way we will discuss how these features appear in mainstream
languages, which languages got the feature right, and which languages got the
feature wrong.

## Language Features

-   Variables and Binding (substitution and environments)

        let x = 1 in
        let y = 2 in
        x + y

        let x = 1 in
        x + y

        let x = 1 in
        let x = 2 in
        x + x

-   Functions (closures)

        let f = fun x â‡’ x + x in â€¦

        let x = 2 in
        let f = fun y â‡’ y * x in â€¦

-   Mutation (indirection and stores)

        let x = box 1 in
        x â† 2 ;
        !x

    At this point in the class, we have:

        âŸ¦_âŸ§ âˆˆ exp â†’ env Ã— store â‡€ store Ã— value

- Core OO (self reference, records)
- Inheritance (dynamic dispatch)
- Types (type checking, inference, soundness)
- Program Analysis (finding bugs, proving absence of bugs)
- Approaches to Semantics (big-step, small-step, denotational, interpreters)
- Effects (monads)
- Verification (dependent types)

Interesting linguistic features not covered:

- Relational programming
- Parallel programming
- Concurrent programming
- Distributed programming

â€¦although, if your language has good support for monads, one can usually embed
these linguistic concepts in a monadic API; â€œthere's a monad for thatâ€.

## Haskell Setup

See [Haskell Setup].

[Haskell Setup]: ../haskell-setup.html
</pre>

</main>

<!-- Bootstrap core JavaScript -->
<!-- ================================================== -->
<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
<!-- ================================================== -->

<!-- Showdown -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/1.8.6/showdown.min.js"></script>

<!-- Darais JS -->
<script src="http://david.darais.com/js/darais-v0.0.0.3.js"></script>

<!-- CUSTOM -->
<script>
</script>
  
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-70126522-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-70126522-1');
</script>

</body>
</html>
