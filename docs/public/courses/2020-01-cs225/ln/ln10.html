<!doctype html>
<html lang="en">
<head>
  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">

  <!-- Darais CSS -->
  <link rel="stylesheet" href="http://david.darais.com/css/darais-v0.0.0.3.css">

  <!-- Title -->
  <meta name="title" content="!!!TITLE!!!">

</head>

<body>

<main>

<pre class=markdown>
[10 - Substitution and Functions](#title)

# Review

1.  Let's play the scope game. Work together in groups. Identify each of these:

    1.  Circle binders
    2.  Draw a bracket for each scope with an incoming arrow from its binder
    3.  Draw an arrow from each variable reference to its binder
    4.  Draw a square around every free variable

    for the following terms:

    -   `let x = 1 in x + x`
    -   `x + let x = 1 in x`
    -   `let x = let x = x in x in x`
    -   `let x = x in let x = x in x`

2.  Consider this language:

        i âˆˆ â„¤
        b âˆˆ ğ”¹
        e âˆˆ expr â©´ i | e + e | b | if e then e else e
        v âˆˆ value â©´ i | b
        a âˆˆ answer â©´ v | bad

    *Without any help*, write a Haskell function which converts expressions which
    are also constants (`i` and `b` expressions) into value answers, and all maps
    all other non-constant expressions to `bad`.

        data Expr = 
            IntE Integer 
          | PlusE Expr Expr
          | BoolE Bool
          | IfE Expr Expr Exp
        data Value =
            IntV Integer
          | BoolV Bool
        data Answer =
            ValueA Value
          | BadA

        convert :: Expr -> Answer
        convert e = ...

# Substitution

Last time we saw an interpreter for variables and let statements which used an
environment.

    i âˆˆ â„¤
    x âˆˆ var
    e âˆˆ expr â©´ i | e + e | x | let x = e in e
    v âˆˆ value â©´ i | b
    a âˆˆ answer â©´ v | bad
    Î³ âˆˆ env â‰œ var â‡€ value

    interp âˆˆ env Ã— expr â†’ answer
    interp(Î³,i) â‰œ i
    interp(Î³,eâ‚ + eâ‚‚) â‰œ iâ‚ + iâ‚‚
      where iâ‚ = interp(Î³,eâ‚)
            iâ‚‚ = interp(Î³,eâ‚‚)
    interp(Î³,x) â‰œ Î³(x)
    interp(Î³,let x = eâ‚ in eâ‚‚) â‰œ interp(Î³â€²,eâ‚‚)
      where Î³â€² = Î³[xâ†¦v]
            v = interp(Î³,eâ‚)


An alternative way to define this interpreter is to perform a direct
substitution of values for variables, rather than â€œdelayingâ€ this substitution
with an environment.

    interp âˆˆ exp â†’ answer
    interp(i) â‰œ i
    interp(eâ‚ + eâ‚‚) â‰œ iâ‚ + iâ‚‚
      where iâ‚ = interp(eâ‚)
            iâ‚‚ = interp(eâ‚‚)
    interp(let x = eâ‚ in eâ‚‚) â‰œ interp([v/x]eâ‚‚)
      where v = interp(eâ‚)

A call-by-name implementation is even simpler:

    interp(Î³,let x = eâ‚ in eâ‚‚) â‰œ interp([eâ‚/x]eâ‚‚)

Both of these definitions use the substitution *metafunction* which replaces
all occurrences of a variable with something. Substitution is an algorithmic
thing which you need to implement in your homework, and has the following
definition:

    [_/_]_ âˆˆ expr Ã— var Ã— expr â‡€ expr
    [eâ‚/x]i â‰œ i
    [eâ‚/x](eâ‚‚â‚ + eâ‚‚â‚‚) â‰œ [eâ‚/x]eâ‚‚â‚ + [eâ‚/x]eâ‚‚â‚‚
    [eâ‚/x]x â‰œ eâ‚
    [eâ‚/x]y â‰œ y  where  x â‰  y
    [eâ‚/x](let x â‰œ eâ‚‚â‚ in eâ‚‚â‚‚) â‰œ let x = [eâ‚/x]eâ‚‚â‚ in eâ‚‚â‚‚
    [eâ‚/x](let y â‰œ eâ‚‚â‚ in eâ‚‚â‚‚) â‰œ let x = [eâ‚/x]eâ‚‚â‚ in [eâ‚/x]eâ‚‚â‚‚  where  x â‰  y

This definition only works if `eâ‚` is *closed*, otherwise it is susceptible to
*variable capture*. E.g.:

    let x = y in let y = 1 in x
    â‰¡
    [y/x](let y = 1 in x) 
    â‰¡ 
    let y = 1 in y

We will only ever be substituting values in our interpreter, and values are
always closed, so this is an ok assumption for us, but be aware it is not ok in
general. A more general substitution algorithm is possible which doesn't assume
closed `eâ‚`, and it essentially renames binders with fresh names to avoid the
variable capture problem.

# Functions

The next feature we will add to our programming language is functions. These
will be top-level function definition, and the ability to call functions within
expressions. We imagine the ability to write programs like this:

    def plus-one(x) = x + 1
    def plus-two(x) = x + 2
    do
    plus-one(10) + plus-two(20)
    â‰¡
    33

What about this program, does it make sense?

    def f(x) = g(x)
    def g(x) = if x == 1 then 100 else f(1)
    do
    g(10)

What is the scoping structure?

Here is the formal definition of the language:

    x âˆˆ var
    f âˆˆ fvar
    e âˆˆ expr â©´ â€¦ | f(e,â€¦,e)
    c âˆˆ command â©´ def f(x,â€¦,x) = e
    p âˆˆ program â©´ c â€¦ c do e

    v âˆˆ value â©´ i | b
    a âˆˆ answer â©´ v | bad

    Î³ âˆˆ env â‰œ var â‡€ value
    fÎ³ âˆˆ fenv â‰œ fvar â‡€ â„’(var) Ã— expr

First, let's discuss the scoping structure of functions. In function
definitions `f(x,â€¦,x) = e`, each of the `x` are *binders*, and the scope of
each binder is `e`. 

Normal variables are different than function variables, and likewise, their
scopes are different. This is made extra explicit in the fact that there are
separate environments for values and functions.

FYI: we will eventually get rid of this extra scope and environment because it
isn't fundamentally necessary.

Notational change: We are going to start using the notation `âŸ¦_âŸ§` to denote the
interpretation of something, so `âŸ¦eâŸ§` for the interpretation of the expression
`e`, `âŸ¦câŸ§` as the interpretation for the command `c`, and `âŸ¦pâŸ§` as the
interpretation of the program `p`. `âŸ¦câŸ§` is a function, and we will write
`âŸ¦câŸ§(fÎ³)` for the interpretation of the command applied to function environment
`fÎ³`. `âŸ¦eâŸ§` takes two extra parameters, the function environment `fÎ³` and the
regular environment `Î³`, and we write `âŸ¦eâŸ§(fÎ³,Î³)` as the interpretation of `e`
under these environments.

We now have a number of interpreters:

    interp-expr âˆˆ fenv Ã— env Ã— expr â†’ answer
    interp-command âˆˆ fenv Ã— command â†’ fenv
    interp-program âˆˆ program â†’ answer

Let's start by interpreting a program:

    interp-program(câ‚ â€¦ câ‚™ do e) â‰œ interp(fÎ³â‚™,âˆ…,e)
      where fÎ³áµ¢ = interp-command(fÎ³áµ¢â‚‹â‚,cáµ¢)
            fÎ³â‚ = âˆ…

    interp-command(fÎ³,def f(xâ‚,â€¦,xâ‚™) = e) â‰œ fÎ³[f â†¦ âŸ¨xâ‚,â€¦,xâ‚™,eâŸ©]

    interp-expr(fÎ³,Î³,f(eâ‚,â€¦,eâ‚™)) â‰œ interp(fÎ³,Î³[xáµ¢â†¦váµ¢],e)
      where âŸ¨xâ‚,â€¦,xâ‚™âŸ©,e = fÎ³(f)
            váµ¢ = interp(fÎ³,âˆ…,eáµ¢)

There are lots of lists of things now, and implicit constraints, such as the
fact that the number of arguments to the function `n` is the same as the number
of function parameters `n`.
</pre>

</main>

<!-- Bootstrap core JavaScript -->
<!-- ================================================== -->
<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
<!-- ================================================== -->

<!-- Showdown -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/1.8.6/showdown.min.js"></script>

<!-- Darais JS -->
<script src="http://david.darais.com/js/darais-v0.0.0.3.js"></script>

<!-- CUSTOM -->
<script>
</script>
  
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-70126522-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-70126522-1');
</script>

</body>
</html>
