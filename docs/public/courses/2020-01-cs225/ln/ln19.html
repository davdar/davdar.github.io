<!doctype html>
<html lang="en">
<head>
  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">

  <!-- Darais CSS -->
  <link rel="stylesheet" href="http://david.darais.com/css/darais-v0.0.0.3.css">

  <!-- Title -->
  <meta name="title" content="!!!TITLE!!!">

</head>

<body>

<main>

<pre class=markdown>
[19 - Program Analysis II](#title)

# Program Analysis II

### Abstracting Elements

Now that we have abstract representations for values (`vÌ‚alue`) and answers
(`aÌ‚nswer`), we need to define how to take a particular concrete `value` or
`answer` and lift it to an abstract `vÌ‚alue` or `aÌ‚nswer`. We are going to notate
this lifting with â€œfloorâ€ brackets `âŒŠ_âŒ‹`.

    âŒŠ_âŒ‹ âˆˆ â„¤ â†’ â„¤Ì‚
    âŒŠiâŒ‹ â‰œ [i,i]

    âŒŠ_âŒ‹ âˆˆ ğ”¹ â†’ ğ”¹Ì‚
    âŒŠbâŒ‹ â‰œ {b}

    âŒŠ_âŒ‹ âˆˆ ğ”¹ â†’ vÌ‚alue
    âŒŠbâŒ‹ = âŸ¨âŠ¥,âŒŠbâŒ‹âŸ©

    âŒŠ_âŒ‹ âˆˆ â„¤ â†’ vÌ‚alue
    âŒŠiâŒ‹ = âŸ¨âŒŠiâŒ‹,âˆ…â­

    âŒŠ_âŒ‹ âˆˆ value â†’ aÌ‚nswer
    âŒŠvâŒ‹ = âŸ¨false,âŒŠvâŒ‹âŸ©

    âŒŠbadâŒ‹ âˆˆ aÌ‚nswer
    âŒŠbadâŒ‹ = âŸ¨true,âŠ¥âŸ©

Notice that the notation is very overloaded based on context.

### Abstract Operations

Plus is a little tricky over abstract answers. Consider the following program:

    aÌ‚ â‰œ âŸ¨true,[1,2],âˆ…âŸ©
    aÌ‚ + âŒŠ5âŒ‹

Here, `aÌ‚` is an abstract answer that represents a computation which either (1)
could fail (encoded by the first `true` element), or (2) returns an integer
between `1` and `2` (encoded by the second `[1,2]` element). There are no
possible boolean values that `aÌ‚` represents, or the program that is abstracted
by `aÌ‚` could return.

The abstract result should be:

    âŸ¨true,[6,7],âˆ…âŸ©

indicating that (1) the program could fail, and (2) it may return integers
within the range `[6,7]`, and (3) there are no booleans it could possibly
return.

What about:

    aÌ‚ â‰œ âŸ¨false,[1,2],{true}âŸ©
    aÌ‚ + 5

the abstract result should be the same as before:

    âŸ¨true,[6,7],âˆ…âŸ©

The reason this program could fail is because the left-hand side argument could
be a boolean `true`, which will cause the plus to fail with a runtime type
error. The program *cannot* return any booleans, because booleans are never a
possible output to plus when it succeeds.

Following these intuitions, we design plus for answers as follows:

    _+Ì‚_ âˆˆ aÌ‚nswer Ã— aÌ‚nswer â†’ aÌ‚nswer
    âŸ¨bâ‚,iÌ‚â‚,bÌ‚â‚âŸ© +Ì‚ âŸ¨bâ‚‚,iÌ‚â‚‚,bÌ‚â‚‚âŸ© â‰œ âŸ¨bâ€²,iÌ‚â€²,bÌ‚â€²âŸ©
      where bâ€² = bâ‚ âˆ¨ bâ‚‚ âˆ¨ (bÌ‚â‚ â‰  âˆ…) âˆ¨ (bÌ‚â‚‚ â‰  âˆ…)
            iÌ‚â€² = iÌ‚â‚ +Ì‚ iÌ‚â‚‚
            bÌ‚â€² = âˆ…

The definition for conditionals is as follows:

    cÌ‚ond âˆˆ aÌ‚nswer Ã— aÌ‚nswer Ã— aÌ‚nswer â†’ aÌ‚nswer
    cÌ‚ond(âŸ¨bâ‚,iÌ‚â‚,bÌ‚â‚âŸ©,âŸ¨bâ‚‚,iÌ‚â‚‚,bÌ‚â‚‚âŸ©,âŸ¨bâ‚ƒ,iÌ‚â‚ƒ,bÌ‚â‚âŸ©) â‰œ âŸ¨bâ€²,iÌ‚â‚â€²âŠ”iÌ‚â‚‚â€²,bÌ‚â‚â€²âˆªbÌ‚â‚‚â€²âŸ©
      where bâ€² = bâ‚ âˆ¨ (iÌ‚â‚ â‰  âŠ¥) âˆ¨ (true âˆˆ bÌ‚â‚ âˆ§ bâ‚‚) âˆ¨ (false âˆˆ bÌ‚â‚‚ âˆ§ bâ‚ƒ)
            iÌ‚â‚â€² = iÌ‚â‚‚   if true âˆˆ bÌ‚â‚
            iÌ‚â‚â€² = âŠ¥    if true âˆ‰ bÌ‚â‚
            iÌ‚â‚‚â€² = iÌ‚â‚ƒ   if false âˆˆ bÌ‚â‚
            iÌ‚â‚‚â€² = âŠ¥    if false âˆ‰ bÌ‚â‚
            bÌ‚â‚â€² = bÌ‚â‚‚   if true âˆˆ bÌ‚â‚
            bÌ‚â‚â€² = âˆ…    if true âˆ‰ bÌ‚â‚
            bÌ‚â‚‚â€² = bÌ‚â‚ƒ   if false âˆˆ bÌ‚â‚
            bÌ‚â‚‚â€² = âˆ…    if false âˆ‰ bÌ‚â‚

A simpler way to write (and implement) this logic is using the join and bottom
operations for abstract answers:

    cÌ‚ond âˆˆ aÌ‚nswer Ã— aÌ‚nswer Ã— aÌ‚nswer â†’ aÌ‚nswer
    cÌ‚ond(âŸ¨bâ‚,iÌ‚â‚,bÌ‚â‚âŸ©,aÌ‚â‚‚,aÌ‚â‚ƒ) â‰œ aÌ‚â‚â€² âŠ” aÌ‚â‚‚â€² âŠ” aÌ‚â‚ƒâ€²
      where aÌ‚â‚â€² = âŸ¨ bâ‚ âˆ¨ (iÌ‚â‚ â‰  âŠ¥) , âŠ¥ âŸ©
            aÌ‚â‚‚â€² = aÌ‚â‚‚  if true âˆˆ bÌ‚â‚
            aÌ‚â‚‚â€² = âŠ¥   if true âˆ‰ bÌ‚â‚
            aÌ‚â‚ƒâ€² = aÌ‚â‚ƒ  if false âˆˆ bÌ‚â‚
            aÌ‚â‚ƒâ€² = âŠ¥   if false âˆˆ bÌ‚â‚

## The Analyzer

The analyzer for a core language is just a slightly non-standard interpreter
with abstract values:

    e âˆˆ expr â©´ i | e + e
             | b | if e then e else e
             | x | let x = e in e
    Î³Ì‚ âˆˆ eÌ‚nv â‰œ var â‡€ vÌ‚alue

    âŸ¦_âŸ§(_) âˆˆ expr â†’ eÌ‚nv â†’ aÌ‚nswer
    âŸ¦iâŸ§(Î³Ì‚) â‰œ âŒŠiâŒ‹
    âŸ¦eâ‚+eâ‚‚âŸ§(Î³Ì‚) â‰œ âŸ¦eâ‚âŸ§(Î³Ì‚) +Ì‚ âŸ¦eâ‚‚âŸ§(Î³Ì‚)
    âŸ¦bâŸ§(Î³Ì‚) â‰œ âŒŠbâŒ‹
    âŸ¦if eâ‚ then eâ‚‚ else eâ‚ƒâŸ§(Î³Ì‚) â‰œ cÌ‚ond(âŸ¦eâ‚âŸ§(Î³Ì‚),âŸ¦eâ‚‚âŸ§(Î³Ì‚),âŸ¦eâ‚ƒâŸ§(Î³Ì‚))
    âŸ¦xâŸ§(Î³Ì‚) â‰œ lift(Î³Ì‚(x))     if x âˆˆ Î³
    âŸ¦xâŸ§(Î³Ì‚) â‰œ âŒŠbadâŒ‹          if x âˆ‰ Î³
    âŸ¦let x = eâ‚ in eâ‚‚âŸ§ â‰œ âŸ¨bâ‚âˆ¨bâ‚‚,vÌ‚â‚‚âŸ©
      where âŸ¨bâ‚,vÌ‚â‚âŸ© = âŸ¦eâ‚âŸ§(Î³Ì‚)
            âŸ¨bâ‚‚,vÌ‚â‚‚âŸ© = âŸ¦eâ‚‚âŸ§(Î³Ì‚[xâ†¦vÌ‚â‚])

The only new operation here is `lift`, which lifts an abstract value to an
abstract answer:

    lift âˆˆ vÌ‚alue â†’ aÌ‚nswer
    lift(vÌ‚) â‰œ âŸ¨false,vÌ‚âŸ©

## Lattices and Partial Orders

Lattices are the general structure that each abstract domain should have, and
partial orders are the notion of ordering that lattices induce.

A lattice is some set `A` with the two special elements called â€œtopâ€ and
â€œbottomâ€:

    âŠ¥ âˆˆ A
    âŠ¤ âˆˆ A

and two special operators called â€œjoinâ€ and â€œmeetâ€, or â€œleast-upper-boundâ€ and
â€œgreatest-lower-boundâ€.

    _âŠ”_ âˆˆ A Ã— A â†’ A
    _âŠ“_ âˆˆ A Ã— A â†’ A

along with these operators, there is an ordering (a relation) induced by the
operators:

    _âŠ‘_ âˆˆ â„˜(A Ã— A)

You should use powersets (whose elements are â€œjust setsâ€) as your grounding
intuition for lattices. Lattices enjoy most of the nice properties that sets
have, except for one specific one, distributivity:

    (A âˆª B) âˆ© C = (A âˆ© C) âˆª (B âˆ© C)

This is true in set world, but not (necessarily) true in lattice world. Lattice
symbols and ordering are intended to suggest analogies with set-based
operations:

    âŠ¥ â‰ˆ âˆ…
    âŠ¤ â‰ˆ A        (the whole set)
    _âŠ”_ â‰ˆ _âˆª_
    _âŠ“_ â‰ˆ _âˆ©_
    _âŠ‘_ â‰ˆ _âŠ†_

The ordering is related to join and meet (and is often *defined* in terms of)
in the following way:

    x âŠ‘ y â¬„ x âŠ” y = y
    x âŠ‘ y â¬„ x âŠ“ y = x

This is also true of sets:

    x âŠ† y â¬„ x âˆª y = y
    x âŠ† y â¬„ x âˆ© y = x

Two elements of a lattice need not be ordered in either direction. This is also
true of sets: for any sets `X` and `Y`, it need not be the case that `X âŠ† Y` or
`Y âŠ† X`. E.g., {1,2,3} and {2,3,4}.

General properties of lattices are the following equations (which are also true
of sets):

    âŠ¥ âŠ” x = x
    âŠ¤ âŠ” x = âŠ¤
    x âŠ” y = y âŠ” x
    (x âŠ” y) âŠ” z = x âŠ” (y âŠ” z)
    x âŠ” x = x

    âŠ¤ âŠ“ x = x
    âŠ¥ âŠ“ x = âŠ¥
    x âŠ“ y = y âŠ“ x
    (x âŠ“ y) âŠ“ z = x âŠ“ (y âŠ“ z)
    x âŠ“ x = x

## Fixpoints and Widening

Fixpoint-finding and widening are necessary techniques to achieve tractable,
computable analyses for non-trivial programs (e.g., even to handle a simple
while loop).

Consider this example (in an imperative language):

    function f(x) {
      assert(xâ‹—0);
      i â‰” 0;
      while(iâ‹–x) { iâ§º; }
      return i;
    }

This program takes a strictly positive number as input, and returns that same
number as output. It always terminates. The reason why this terminates is due
to a loop invariant where `i â‰¤ x`. When the loop exits, we know that `i â‰¤ x`
due to the loop invariant,  and `Â¬ iâ‹–x` due to the guard failing, which
implies `i = x`.

Currently we do not track *relationships* between variables in our abstract,
just ranges of values. Our abstract interpreter might look at this program and
start off as â€œwe know `x` is strictly positive and that`i` is `0`â€.

    x = [1,âˆ]
    i = [0,0]
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    while(iâ‹–x) { iâ§º; }

It will update `i` to account for the fact that `i` could be `0` (before the
loop) or `1` (after one loop iteration), and then try the loop again:

    x = [1,âˆ]
    i = [0,1]
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    while(iâ‹–x) { iâ§º; }

A naive implementation of this analysis will loop forever, *even though our
concrete program didn't loop forever*. It is therefore especially important
that we teach our analysis how to stop at some pointâ€“not just for looping
programs, but for non-looping ones too.

Let's try a different version of this program with booleans:

    function f(x) {
      i â‰” true;
      while(i) { i = i âˆ§ x; }
      return i;
    }

we accumulate facts about `x` (could be any boolean) and `i` (definitely true):

    x = {true,false}
    i = {true}
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    while(i) { i = i âˆ§ x; }

we know the loop gets taken at least once, resulting in:

    x = {true,false}
    i = {true,false}
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    while(i) { i = i âˆ§ x; }

now one of two things happens: (1) we take the loop again, and `x` and `i`
don't change, or (2) we exit the loop. The â€œ`x` and `i` don't changeâ€ bit is
the crucial thing to notice. This means we have reached a â€œfixed-pointâ€ for the
input loop as a transformation on the (abstracted) state of the program. We
could run the loop once more or 10 billion times more, the result will stay the
same. It is therefore safe to stop here, not run the loop any longer, and
report the current results as an abstraction of *any possible number of runs*
of the loop.

This technique in general is called Kleene fixpoint iteration and relies on (1)
a proper lattice, (2) the lattice not having any infinitely ascending chains
(i.e., is either finite or can be ascended in a finite number of steps), (3)
the update to analysis being monotonic, and (4) iterating the loop, starting at
bottom, until it reaches a fixpoint. Kleene's fixpoint theorem tells you this
will always terminate in a *finite* number of steps, and is a sound
approximation of any *infinite* number of loop rounds.

In order to make this work for the interval lattice, we can't rely on the fact
that the lattice is finite (because it isn't), and instead we need to find a
way to climb the lattice in a finite number of steps. To do this, we notice
when one side of the interval is growing towards negative or positive infinity,
and just jump there pre-maturely as a conservative approximation.

As before, we go from here:

    x = [1,âˆ]
    i = [0,0]
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    while(iâ‹–x) { iâ§º; }

to here

    x = [1,âˆ]
    i = [0,1]
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    while(iâ‹–x) { iâ§º; }

and notice that the upper bound for `i` is marching towards infinity. We could
do this once more (for good measure):

    x = [1,âˆ]
    i = [0,2]
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    while(iâ‹–x) { iâ§º; }

and see that yes, indeed, things are not looking good for that upper bound.
Let's bump it to infinity pre-emptively, and then run again:

    x = [1,âˆ]
    i = [0,+âˆ]
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    while(iâ‹–x) { iâ§º; }

Here the input bounds on `x` and `i` are not changed by the loopâ€“we have
reached a fixed-point. We can stop running the loop, and return `i = [0,+âˆ]` as
a conservative approximation for the function's behavior. The important thing
is that we arrived at the answer in a low constant number of loop iterations.

</pre>

</main>

<!-- Bootstrap core JavaScript -->
<!-- ================================================== -->
<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
<!-- ================================================== -->

<!-- Showdown -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/1.8.6/showdown.min.js"></script>

<!-- Darais JS -->
<script src="http://david.darais.com/js/darais-v0.0.0.3.js"></script>

<!-- CUSTOM -->
<script>
</script>
  
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-70126522-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-70126522-1');
</script>

</body>
</html>
