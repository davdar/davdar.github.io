<!doctype html>
<html lang="en">
<head>
  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">

  <!-- Darais CSS -->
  <link rel="stylesheet" href="http://david.darais.com/css/darais-v0.0.0.1.css">

  <!-- Title -->
  <meta name="title" content="Lecture Notes: 02">

</head>

<body>

<main>

<pre class=markdown>

# Course Technical Introduction

## Context w.r.t. Models of Computation

- First(ish) model of computation: Turing Machines (TM) (Turing, 1936)
  - First model for what an algorithm (1) *is*, (2) *is capable of* and (3) *is
    not capable of*.
  - Low level, intuitive abstraction for a â€œmachineâ€
  - â€œTransition rulesâ€ as (not great) abstraction for code
  - â€œInfinite tapeâ€ as (good) abstraction for memory
  - â€œRule applicationâ€ as (mixed) abstraction for program execution
  - Not a programming language

E.g.:

    âŸ¨Q,Î“,b,Î£,Î´,qâ‚€,FâŸ©
    Q â‰œ {1,2,3}
    F â‰œ {'a','b',' '}
    b â‰œ ' '
    Î£ â‰œ {'a','b'}
    qâ‚€ â‰œ 1
    F â‰œ {2,3}
    Î´(1,'a',R) â‰œ (2,' ')
    Î´(1,'b',R) â‰œ (3,' ')

- Second(ish) model of computation: Lambda Calculus (LC) (Church, 1936)
  - Church and Turing were buds
  - Simpler than TMs
  - Direct connections with formal logic
  - â€œSymbolic expressionâ€ as (good) abstraction for code
  - â€œSize of symbolic expressionâ€ as (not great) abstraction for memory
  - â€œSubstitutionâ€ as (mixed) abstraction for program execution
  - Basis for understanding all programming language
  - Basis for design of functional programming languages

E.g.:

    Î»x.x      -- conditional
    Î»x.Î»y.x   -- true
    Î»x.Î»y.y   -- false

*Early programming languages looked more like Turing Machines, modern
programming languages look more like lambda calculus.* They were invented
around the same time...

*Running theme in this course: Everything â€œnewâ€ in programming language
modeling and design that hits mainstream is actually very very old.*

TM and LC were developed to study what computer programs are capable of. For
example, there is Turing's famous halting problem which states:

> There does not exist a turing machine M that takes as input another turing
> machine N, and eventually halts with one output bit which is true iff N
> halts, and false iff N does not halt.

I.e., the â€œhalting problemâ€ is undecidable.

## Programming Language Semantics

For now we are less interested in â€œhowâ€ computation happens, and more
interested in â€œwhatâ€ a computation means. For this reason we will not use
either TM or LC as a framework for studying the meaning of programs. For now we
will use intermediate discrete math.

What does this program mean? (APL, 1966)

    â†‘+.Ã—/N/âŠ‚2 2â´1 1 1 0

*Obviously* this is the Fibonacci sequence. How do we *show* this is the case?
We need a semantics for APL, and a description of the Fibonacci sequence in
that semantic domain. Here's what this looks like abstractly.

(examples taken from: http://microapl.com/APL/getting_started_chapter1.html)

    APL-term âˆˆ set

    e.g., 
      1 âˆˆ APL-term             -- evaluates to 1
      1+1 âˆˆ APL-term           -- evaluates to 2
      1+1 2 3 âˆˆ APL-term       -- evaluates to 2 3 4
      1 2+3 4 5 âˆˆ? APL-term    -- error (syntax error or evaluation error?)
      3Ã—3-1 âˆˆ APL-term         -- evaluates to 6
      2 3 1+8Ã·2 2 2 âˆˆ APL-term -- evaluates to 6 7 5

Now that we have a (mathematical) set of APL-terms, let's define a
(mathematical) set for results of APL expressions:

    â„ âˆˆ set
    â„* âˆˆ set

    APL-result âˆˆ set
    APL-result â‰œ â„*

What does `â„*` mean?

    â„Â¹ â‰œ â„
    â„Â² â‰œ â„ Ã— â„ 
       = {âŸ¨x,yâŸ© | x âˆˆ â„, y âˆˆ â„âµ
    â„Â³ â‰œ â„ Ã— â„ Ã— â„
    â„* â‰œ âˆƒnâˆˆâ„•. â„â¿

The notation is precise (good) but more intimidating than necessary. `â„*` is
just a list of real numbers. In java, you might use the type
`ArrayList<Double>`.

Programming languages are given meaning through an *interpretation* function,
written with funny brackets called â€œOxford bracketsâ€:

    âŸ¦_âŸ§ âˆˆ APL-term â‡€ APL-result

*Aside:* We often standardize on metavariables to implicitly always live in a
particular set. We will use the following implicit metavariables:

    r âˆˆ â„
    e âˆˆ APL-term

The set `APL-term` is defined as an inductively defined set:

    râ‚ â€¦ râ‚™ âˆˆ APL-term      -- râ‚ â€¥ râ‚™ IS AN APL-term

    eâ‚ âˆˆ APL-term           -- IF eâ‚ IS AN APL-term
    eâ‚‚ âˆˆ APL-term           -- AND eâ‚‚ IS AN APL-term
    ----------------------  --
    eâ‚ + eâ‚‚ âˆˆ APL-term      -- THEN eâ‚ + eâ‚‚ IS AN APL-term

    e âˆˆ APL-term            -- IF e IS AN APL-term
    ----------------        --
    r Ã— e âˆˆ APL-term        -- THEN r Ã— e IS AN APL-term

which is often abbreviated as:

    e âˆˆ APL-term â©´ r â€¦ r | e + e | r Ã— e

The interpretation function is defined by induction on the syntax.

    âŸ¦râ‚ â€¦ râ‚™âŸ§ â‰œ âŸ¨râ‚,â€¦,râ‚™âŸ© âˆˆ â„â¿ âŠ† â„*
    âŸ¦eâ‚ + eâ‚‚âŸ§ â‰œ âŸ¨râ‚+sâ‚,â€¦,râ‚™+sâ‚™âŸ© âˆˆ â„â¿ âŠ† â„*
      where
        âŸ¨râ‚,â€¦,râ‚™âŸ© = âŸ¦eâ‚âŸ§ âˆˆ â„â¿
        âŸ¨sâ‚,â€¦,sâ‚™âŸ© = âŸ¦eâ‚‚âŸ§ âˆˆ â„â¿
    âŸ¦r Ã— eâŸ§ â‰œ âŸ¨rÃ—sâ‚,â€¦,rÃ—sâ‚™âŸ© âˆˆ â„â¿ âŠ† â„*
      where
        âŸ¨sâ‚,â€¦,sâ‚™âŸ© = âŸ¦eâŸ§ âˆˆ â„â¿

Note that this definition is partial because `âŸ¦eâ‚ + eâ‚‚âŸ§` requires the meaning
of both `eâ‚` and `eâ‚‚` to have the same dimension. This is why the set that
`âŸ¦_âŸ§` lives in was written with a `â‡€` and not `â†’`â€”to indicate this
â€œpartialityâ€.

Moving to a slightly more abstract description:

*A â€œlanguageâ€ `â„’` is some inductively defined set of symbols with finite
length.*

*A â€œdenotationâ€ `ğ’Ÿ` is some well-defined mathematical set.*

*A â€œdenotational semanticsâ€ is a function `âŸ¦_âŸ§ âˆˆ â„’ â†’ ğ’Ÿ` which gives mathematical
meaning to language terms.*

*Aside:* What happened to the partiality of `âŸ¦_âŸ§`, i.e., the partial arrow
â€œ`â‡€`â€? Partiality is easy to disguise as totality by extending a set with a
distinguished element `âŠ¥`. Formally, this equivalence is written `A â‡€ B = A â†’ B
âŠ {âŠ¥}`. The operator `âŠ` is pronounced â€œdisjoint unionâ€ and `{âŠ¥}` is a
singleton set. `B âŠ {âŠ¥}` means â€œa set that is just like B, but contains exactly
one new element `âŠ¥`, which is guaranteed to be different than all elements of
`B`.â€

Why are we doing this? Consider these two APL programs:

    eâ‚ â‰œ 3 4+3 4

    eâ‚‚ â‰œ 2Ã—3 4

These are *different programs*, that is, `eâ‚ â‰  eâ‚‚`, however, they are
*equivalent programs*, i.e., they have the same meaning, which is shown by
`âŸ¦eâ‚âŸ§ = âŸ¦eâ‚‚âŸ§`.

The value of this approach is we can extend our notion of equivalence to
programs with variables:

    eâ‚ â‰œ a b+a b
    eâ‚‚ â‰œ 2Ã—a b
  
These *programs fragments* are also equivalent, even thought they are not
â€œcomplete programsâ€ (i.e., they have â€œfree variablesâ€).

*Aside:* what's a compiler? A compiler is (1) another language `ğ’` which is
typically a much lower level of abstraction, and suitable for execution on
hardware (e.g., assembly code), (2) a semantics for `ğ’` as `âŸ¦_âŸ§ âˆˆ ğ’ â†’ ğ’Ÿ`, and
(3) a function `compile âˆˆ â„’ â†’ ğ’` which preserves the meaning of programs, that
is, `âŸ¦compile(e)âŸ§ = âŸ¦eâŸ§`.

## Course Structure

The first 1/2 of the course will follow a pattern:

1. Start with the smallest language we can think of: `â„’`
2. Design a domain `ğ’Ÿ` in which we will give meaning to the language
3. Implement and interpreter for this language in Haskell (`âŸ¦_âŸ§ âˆˆ â„’ â†’ ğ’Ÿ`)
4. Extend the language with one new programming language feature
5. GOTO 2

Along the way we will discuss how these features appear in mainstream
languages, which languages got the feature right, and which languages got the
feature wrong.

## Haskell Setup

See [Haskell Setup].

[Haskell Setup]: ../haskell-setup.html

## Haskell Tutorial

Let's play with `stack ghci`:

    Prelude> 1
    1
    Prelude> :t 1
    1 :: Num p => p
    Prelude> :t 1.1
    1.1 :: Fractional p => p
    Prelude> 1 :: Int
    1
    Prelude> 1 :: Double
    1.0
    Prelude> 1.1 :: Int
    
    <interactive>:6:1: error:
        â€¢ No instance for (Fractional Int) arising from the literal â€˜1.1â€™
        â€¢ In the expression: 1.1 :: Int
          In an equation for â€˜itâ€™: it = 1.1 :: Int
    Prelude> 1.1 :: Double
    1.1
    Prelude> 1 + 1.1
    2.1
    Prelude> :t 1 : 1.1
    1 : 1.1 :: (Fractional [a], Num a) => [a]
    Prelude> :t 1 + 1.1
    1 + 1.1 :: Fractional a => a
    Prelude> 1 / 2
    0.5
    Prelude> 1 `div` 2
    0
    Prelude> :t 1 / 1
    1 / 1 :: Fractional a => a
    Prelude> :t 1 / 2
    1 / 2 :: Fractional a => a
    Prelude> [1,2]
    [1,2]
    Prelude> (1,2)
    (1,2)
    Prelude> :t [1,2]
    [1,2] :: Num a => [a]
    Prelude> :t [1::Int,2]
    [1::Int,2] :: [Int]
    Prelude> :t (1::Int,2)
    (1::Int,2) :: Num b => (Int, b)
    Prelude> :t (1::Int,2::Int)
    (1::Int,2::Int) :: (Int, Int)
</pre>

</main>

<!-- Bootstrap core JavaScript -->
<!-- ================================================== -->
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
<!-- ================================================== -->

<script>
</script>
  
<!-- Showdown -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/1.8.6/showdown.min.js"></script>

<!-- Darais JS -->
<script src="http://david.darais.com/js/darais-v0.0.0.2.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-70126522-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-70126522-1');
</script>

</body>
</html>
